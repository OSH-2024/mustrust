<h1>可行性报告</h1>

- [项目介绍](#项目介绍)
- [理论依据](#理论依据)
  - [使用 Rust 对 C 代码改写的可行性](#使用-rust-对-c-代码改写的可行性)
    - [C 语言指针的改写](#c-语言指针的改写)
    - [C 语言宏定义及条件编译的改写](#c-语言宏定义及条件编译的改写)
- [技术依据](#技术依据)
- [创新点](#创新点)

## 项目介绍
在这个项目中，我们将使用 Rust 语言重新改写 FreeRTOS 操作系统，并使其支持 MMU。

FreeRTOS 是一个热门的嵌入式设备用即时操作系统核心，它于 2003 年由 Richard Barry 设计，并已被经成功移植到 35 种不同的微控制器上。[^1]

在计算机技术日益成熟的今天，C/C++ 语言的弊端也逐渐显现。由于大量的操作基于指针实现，C/C++ 的内存安全问题频出，这样的问题也会在使用 C 语言编写的 FreeRTOS 中显现。而 Rust 的内存安全性恰恰弥补了这方面不足，在对内存安全要求极高的操作系统领域有着举足轻重的地位，同时 Rust 的性能与 C/C++ 不相上下，从长期来看，Rust 具有完全取代 C/C++ 的趋势。

同时，FreeRTOS 本身还存在另一点问题，即不支持内存管理单元（MMU）。在硬件资源有限的单片机中，内存管理单元便显得格外重要。所以，我们将使 FreeRTOS 支持内存管理单元，并在单片机上进行实机测试。

在本报告中，我们将依次分析该项目的理论依据（使用 Rust 对 C 代码改写的可行性、对 FreeRTOS 源码的分析以及 MMU 的实现思路）和技术依据（使用软件测试改写后 FreeRTOS 的方案、使用硬件运行改写后 FreeRTOS 的方案以及对部分代码的改写示例），并提出这个项目中的创新点。

## 理论依据
### 使用 Rust 对 C 代码改写的可行性
下面我们需要针对一些 C 语言中特有的写法，讨论其使用 Rust 改写的可行性。

#### C 语言指针的改写
在调用底层硬件的过程中，我们会无法避免的要使用到指针等不安全代码，而 Rust 中也有其相对应的实现：Unsafe Rust。

Rust 本身执行着非常严格且保守的安全审查，部分代码会因为编译器无法分析出其正确性而被拒绝编译，此时，我们需要使用 `unsafe` 关键字，而我们就需要对这部分 `unsafe` 的代码的安全性负责。同时，`unsafe` 的存在也并不会影响 Rust 本应有的安全性，Rust 中部分对安全的检查在 `unsafe` 块中依然存在。

使用了 `unsafe` 之后，就可以改写 C 语言的指针。下面是一段示例代码：

``` rust
fn main() {
    let a = [1, 1, 4, 5, 1, 4];
    let mut p = &a[1] as *const i32;
    unsafe {
        p = p.add(1);
        println!("The value of p is {}", *p);
    }
}
// The value of p is 4
```

#### C 语言宏定义及条件编译的改写
C 语言的宏和条件编译功能，使得其有非常好的可扩展性，在不同的平台上，只需要在编译器中预定义不同的宏，即可在不需要修改代码的情况下进行跨平台编译。但是，如果宏使用不当，也会造成代码可读性急剧降低的情况，且可能出现其他未预料的情况，比如下面这段代码：

``` c
#include <stdio.h>
#define mul(a, b) a * b

int main() {
    printf("%d\n", mul(1 + 2, 3 + 4)); // 3 * 7 ???
    return 0;
}
// outputs 11 but not 21
```

Rust 中也有宏定义的功能，且与 C 语言的宏相比，Rust 的宏也并不危险，就如上面这段代码，按照其本意改写为 Rust 后如下：

``` rust
macro_rules! mul {
    ($a: expr, $b: expr) => {
        $a * $b
    }
}

fn main() {
    println!("{}", mul!(1 + 2, 3 + 4)); // 21
}
```

代码可以输出正确的结果，而不会像 C 一样输出错误的结果。

对于条件编译的情况，Rust 不需要像 C 一样通过一个 `.h` 文件定义大量的宏来进行编译的配置，而是使用 `Cargo.toml` 文件进行配置，同理也有一些系统配置（如系统类型、位数等）可以直接使用。在代码中，只需要在 if 语句中使用 `cfg!` 宏即可达到条件编译的效果，如下面的代码：

``` rust
fn main() {
    let os = if cfg!(windows) {
        "Windows"
    }
    else if cfg!(unix) {
        "Unix"
    }
    else {
        "Unknown"
    };
    let bit = if cfg!(target_pointer_width = "32") {
        "32-bit"
    }
    else if cfg!(target_pointer_width = "64") {
        "64-bit"
    }
    else {
        "What the fxxk?"
    };
    println!("You are using {} {} operating system.", bit, os);
}
```

可以显示你的系统类型以及位数。

## 技术依据

## 创新点

[^1]: https://zh.wikipedia.org/wiki/FreeRTOS
