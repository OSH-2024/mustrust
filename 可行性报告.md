<h1>可行性报告</h1>

- [项目介绍](#项目介绍)
- [理论依据](#理论依据)
  - [使用 Rust 对 C 代码改写的可行性](#使用-rust-对-c-代码改写的可行性)
    - [C 语言指针的改写](#c-语言指针的改写)
    - [C 语言宏定义及条件编译的改写](#c-语言宏定义及条件编译的改写)
  - [FreeRTOS 源码分析](#freertos-源码分析)
    - [总体代码风格](#总体代码风格)
    - [任务相关](#任务相关)
- [技术依据](#技术依据)
- [创新点](#创新点)

## 项目介绍
在这个项目中，我们将使用 Rust 语言重新改写 FreeRTOS 操作系统，并使其支持 MMU。

FreeRTOS 是一个热门的嵌入式设备用即时操作系统核心，它于 2003 年由 Richard Barry 设计，并已被经成功移植到 35 种不同的微控制器上。[^1]

在计算机技术日益成熟的今天，C/C++ 语言的弊端也逐渐显现。由于大量的操作基于指针实现，C/C++ 的内存安全问题频出，这样的问题也会在使用 C 语言编写的 FreeRTOS 中显现。而 Rust 的内存安全性恰恰弥补了这方面不足，在对内存安全要求极高的操作系统领域有着举足轻重的地位，同时 Rust 的性能与 C/C++ 不相上下，从长期来看，Rust 具有完全取代 C/C++ 的趋势。

同时，FreeRTOS 本身还存在另一点问题，即不支持内存管理单元（MMU）。在硬件资源有限的单片机中，内存管理单元便显得格外重要。所以，我们将使 FreeRTOS 支持内存管理单元，并在单片机上进行实机测试。

在本报告中，我们将依次分析该项目的理论依据（使用 Rust 对 C 代码改写的可行性、对 FreeRTOS 源码的分析以及 MMU 的实现思路）和技术依据（使用软件测试改写后 FreeRTOS 的方案、使用硬件运行改写后 FreeRTOS 的方案以及对部分代码的改写示例），并提出这个项目中的创新点。

## 理论依据
### 使用 Rust 对 C 代码改写的可行性
下面我们需要针对一些 C 语言中特有的写法，讨论其使用 Rust 改写的可行性。

#### C 语言指针的改写
在调用底层硬件的过程中，我们会无法避免的要使用到指针等不安全代码，而 Rust 中也有其相对应的实现：Unsafe Rust。

Rust 本身执行着非常严格且保守的安全审查，部分代码会因为编译器无法分析出其正确性而被拒绝编译，此时，我们需要使用 `unsafe` 关键字，而我们就需要对这部分 `unsafe` 的代码的安全性负责。同时，`unsafe` 的存在也并不会影响 Rust 本应有的安全性，Rust 中部分对安全的检查在 `unsafe` 块中依然存在。

使用了 `unsafe` 之后，就可以改写 C 语言的指针。下面是一段示例代码：

``` rust
fn main() {
    let a = [1, 1, 4, 5, 1, 4];
    let mut p = &a[1] as *const i32;
    unsafe {
        p = p.add(1);
        println!("The value of p is {}", *p);
    }
}
// The value of p is 4
```

#### C 语言宏定义及条件编译的改写
C 语言的宏和条件编译功能，使得其有非常好的可扩展性，在不同的平台上，只需要在编译器中预定义不同的宏，即可在不需要修改代码的情况下进行跨平台编译。但是，如果宏使用不当，也会造成代码可读性急剧降低的情况，且可能出现其他未预料的情况，比如下面这段代码：

``` c
#include <stdio.h>
#define mul(a, b) a * b

int main() {
    printf("%d\n", mul(1 + 2, 3 + 4)); // 3 * 7 ???
    return 0;
}
// outputs 11 but not 21
```

Rust 中也有宏定义的功能，且与 C 语言的宏相比，Rust 的宏也并不危险，就如上面这段代码，按照其本意改写为 Rust 后如下：

``` rust
macro_rules! mul {
    ($a: expr, $b: expr) => {
        $a * $b
    }
}

fn main() {
    println!("{}", mul!(1 + 2, 3 + 4)); // 21
}
```

代码可以输出正确的结果，而不会像 C 一样输出错误的结果。

对于条件编译的情况，Rust 不需要像 C 一样通过一个 `.h` 文件定义大量的宏来进行编译的配置，而是使用 `Cargo.toml` 文件进行配置，同理也有一些系统配置（如系统类型、位数等）可以直接使用。在代码中，只需要在 if 语句中使用 `cfg!` 宏即可达到条件编译的效果，如下面的代码：

``` rust
fn main() {
    let os = if cfg!(windows) {
        "Windows"
    }
    else if cfg!(unix) {
        "Unix"
    }
    else {
        "Unknown"
    };
    let bit = if cfg!(target_pointer_width = "32") {
        "32-bit"
    }
    else if cfg!(target_pointer_width = "64") {
        "64-bit"
    }
    else {
        "What the fxxk?"
    };
    println!("You are using {} {} operating system.", bit, os);
}
```

可以显示你的系统类型以及位数。

### FreeRTOS 源码分析
#### 总体代码风格
* **宏定义**：代码中使用了大量的宏定义与条件编译，这部分的可行性已于前面进行过分析。
* **函数定义**：由于 C 语言面向过程的特性，无法使用面向对象语言（如 C++）中的命名空间以及类，所以需要使用特殊的函数名称标识出该函数的一些特性。在 FreeRTOS 的源代码中函数名格式为：返回值类型 + 所在文件 + 函数名。
  * 对于非静态函数，“返回值类型”为若干个小写字母，表示函数的返回值类型，对于 void 函数则为 `v`，对于有返回值的函数则为 `x` 或 `ux`（取决于返回值是否无符号）。对于静态函数，“返回值类型”固定为 `prv`。
  * “所在文件”采用大写字母开头，比如函数在 `list.c` 文件中，则“所在文件”为 `List`。
  * “函数名”采用大驼峰命名法。
  * 例如，`uxListRemove` 函数名表示 `list.c` 文件中的 `Remove` 函数，返回值为无符号的类型。
  * 由于 Rust 为面向对象的编程语言，所以命名函数的时候可以只保留函数名部分。
* **变量定义**：变量名的格式为：变量类型 + 变量名。
  * “变量类型”为若干小写字母，用 `l` 表示 long，`s` 表示 short，`c` 表示 char，其余（包括 size_t 等不同系统中长度不固定的类型）用 `x`。前缀 `u` 表示无符号，`p` 表示指针。如 `puc` 表示指向 `unsigned char` 的一个指针。
  * “变量名”采用大驼峰命名法。
* **注释**：代码中不使用 `//` 注释，所有注释均为 `/* ... */` 格式。函数间有一条分隔线作用的注释。

#### 任务相关
FreeRTOS 的源代码中有一大半都在处理各种任务，下面对 FreeRTOS 的任务系统进行分析。

FreeRTOS 中的任务状态有 5 种：正在运行 `X`、阻塞 `B`、就绪 `R`、删除 `D`、挂起 `S`。含义如下：
+ 正在运行：任务正在运行；
+ 阻塞：任务正在等待某个外部事件，无法正常继续执行；
+ 就绪：任务正在等待资源，当资源充足时开始执行；
+ 删除：任务被删除；
+ 挂起：任务无法继续执行，直到被 Resume。

每个任务还有一个优先级，0 为最低，最高的值在配置文件中，可以自行修改。

下面是任务相关的 API 函数：
+ `xTaskCreate`：创建任务，初始状态为就绪；
+ `xTaskDelete`：删除任务；
+ `xTaskSuspend`：挂起任务，任务进入挂起状态；
+ `xTaskResume`：唤醒任务，任务从挂起状态进入就绪状态。



## 技术依据

## 创新点

[^1]: https://zh.wikipedia.org/wiki/FreeRTOS
